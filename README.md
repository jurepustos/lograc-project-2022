# Update Monads

In this repository, we are using proof assistant `Agda`, to formulise **update monads**, as described in [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf) by Danel Ahman and Tarmo Uustalu.

## Structure of this repository

This repository is set up as an Agda library and it contains:

* `lograc-project.agda-lib`: the library configuration file which contains
  the list of file system paths that Agda should include

* `agda-stdlib/`: Agda standard library as a git submodule

* `agda-categories/`: Agda categories library as a git submodule

* `project/`: the top-level source code directory for our agda code. Here is what we did for our project. Files, that are in-here, are described in next paragraphs.

## Monoids

Representation of monoid and right action (used for update monads) is written in the file `Monoids.agda`

## Classic families of monads

Firstly, we formulised the three classic families of monads, used in functional programming: the reader, writer and state monads. Each of this monads has a separate file (module). We are not going to provied detailed description of them, as you can read everything you need in the original [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf).

**Reader monads** are defined in file `ReaderMonad.agda`. Reader monads are defined by every set of states. In real life (mostly `Haskell`), reader monads are used for representing a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. 

**Writer monads** are defined in file `WriterMonad.agda`. Writer monads are definied by a monoid. The writer monad represents computations which produce a stream of data in addition to the computed values. It is commonly used by code generators to emit code.

**State monads** are again defined by a state. State monads are formulised in file `StateMonad.agda`. The State monad wraps computations in the context of reading and modifying a global state object.

In simpler words, the *reader monad* has a global value we could read from, but not modify, *writer monad* allows us to modify a value by appending, through we can't directly read it during the compuation. *State monad* is a combination of both reader and writer monads.

## Update monads

Update monads are coded in file `UpdateMonad.agda`. Update monads are generated by a set, a monoid and a right action. A computation is a function taking an initial state to an update produced and a return value.

## Algebras of update monads

Algebras of update monads are described in Appendix A2 of the original [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf). Algebra for the update monad is a set with an operation, called **act**. Such algebra is formulised in file `MonadAlgebras.agda`.

However, we also learn in the article, that algebras for update monads can also be presented with two operations, **update** and **lookup**. This representation is coded in file `UpdateMonadAlgebras.agda`.

## Interdefinability

Proofs, that both definitions of algebras of update monads are equivalent, are written in `UpdateMonadAlgebras.agda`.

At first we proved, that a combination of *lookup* and *update* operations (specifically described in the article) suits as an *act* operation (by using some properties of *lookup* and *update*) for the first case of algebras of update monads.

Then we reversed the situation: we wrote *lookup* and *update* functions with *act* operation and then used some properties of *act* to prove needed laws of *lookup* and *update*.

## Compatible compositions

While state monads cannot be described as compatible compositions of reader and writer monads, update monads are exactly that. **Compatible composition** of two monads is described in file `CompatibleComposition.agda`. Distributive law of one monad over other is also defined there. 

The idea is that functor of the update monad is exactly a composition of functors of reader and writer monads. Distributive law of the writer monad over reader monad defines the right action for the update monad.

## Next steps

Next steps for this project:
- algebra of the update monad represented with operations from reader and writer monads
- maps between monads (if there is time)
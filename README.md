# Update Monads

In this repository, we are using proof assistant `Agda`, to formulise **update monads**, as described in [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf) by Danel Ahman and Tarmo Uustalu.

## Structure of this repository

This repository is set up as an Agda library and it contains:

* `lograc-project.agda-lib`: the library configuration file which contains
  the list of file system paths that Agda should include

* `agda-stdlib/`: Agda standard library as a git submodule

* `agda-categories/`: Agda categories library as a git submodule

* `project/`: the top-level source code directory for our agda code. Here is what we did for our project. Files, that are in-here, are described in next paragraphs.

## Monoids

Representation of monoid and right action (used for update monads) is written in the file `Monoids.agda`

## Classic families of monads

Firstly, we formulised the three classic families of monads, used in functional programming: the reader, writer and state monads. Each of this monads has a separate file (module). We are not going to provied detailed description of them, as you can read everything you need in the original [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf).

**Reader monads** are defined in file `ReaderMonad.agda`. Reader monads are defined by every set of states. In real life (mostly `Haskell`), reader monads are used for representing a computation, which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment. 

**Writer monads** are defined in file `WriterMonad.agda`. Writer monads are definied by a monoid. The writer monad represents computations which produce a stream of data in addition to the computed values. It is commonly used by code generators to emit code.

**State monads** are again defined by a state. State monads are formulised in file `StateMonad.agda`. The State monad wraps computations in the context of reading and modifying a global state object.

In simpler words, the *reader monad* has a global value we could read from, but not modify, *writer monad* allows us to modify a value by appending, through we can't directly read it during the compuation. *State monad* is a combination of both reader and writer monads.

## Update monads

Update monads are coded in file `UpdateMonad.agda`. Update monads are generated by a set, a monoid and a right action. A computation is a function taking an initial state to an update produced and a return value.

## Algebras of update monads

Algebras of update monads are described in Appendix A2 of the original [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf). Algebra for the update monad is a set with an operation, called **act**. Such algebra is formulised in file `MonadAlgebras.agda`.

However, we also learn in the article, that algebras for update monads can also be presented with two operations, **update** and **lookup**. This representation is coded in file `UpdateMonadAlgebras.agda`.

## Interdefinability

Proofs, that both definitions of algebras of update monads are equivalent, are written in file `Interdefinability.agda`.

At first we proved, that a combination of *lookup* and *update* operations (specifically described in the article) suits as an *act* operation (by using some properties of *lookup* and *update*) for the first case of algebras of update monads.

Then we reversed the situation: we wrote *lookup* and *update* functions with *act* operation and then used some properties of *act* to prove needed laws of *lookup* and *update*.

## Compatible compositions

While state monads cannot be described as compatible compositions of reader and writer monads, update monads are exactly that. **Compatible composition** of two monads is described in file `CompatibleComposition.agda`. Distributive law of one monad over other is defined in `DistributiveLaw.agda`. 

The idea is, that functor of the update monad is exactly a composition of functors of reader and writer monads. Distributive law of the writer monad over reader monad defines the right action for the update monad. This stil has to be implemented.

## Next steps

Next steps for this project:
- algebra of the update monad represented with operations from reader and writer monads
- maps between monads (if there is time)
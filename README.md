# Update Monads

In this repository, we are using proof assistant `Agda`, to formulise **update monads**, as described in [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf) by Danel Ahman and Tarmo Uustalu.

## Structure of this repository

This repository is set up as an Agda library and it contains:

* `lograc-project.agda-lib`: the library configuration file which contains
  the list of file system paths that Agda should include

* `agda-stdlib/`: Agda standard library as a git submodule

* `agda-categories/`: Agda categories library as a git submodule

* `project/`: the top-level source code directory for our agda code. Here is what we did for our project. Files, that are in-here, are described in next paragraphs.

## Monoids

Representation of monoid and right action (used for update monads) is written in the file `Monoids.agda`

## Classic families of monads

Firstly, we formulised the three classic families of monads, used in functional programming: the reader, writer and state monads. Each of this monads has a separate file (module). We are not going to provied detailed description of them here, as you can read everything you need in the original [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf).

**Reader monads** are defined in file `ReaderMonad.agda`. 

**Writer monads** are defined in file `WriterMonad.agda`.

**State monads** are formulised in file `StateMonad.agda`.

In simpler words, the *reader monad* has a global value we could read from, but not modify, *writer monad* allows us to modify a value by appending, through we can't directly read it during the compuation. *State monad* is a combination of both reader and writer monads.

## Update monads

Update monads are coded in file `UpdateMonad.agda`. Update monads are generated by a set, a monoid and a right action. A computation is a function taking an initial state to an update produced and a return value.

## Algebras of update monads

Algebras of update monads are described in Appendix A2 of the original [article](https://drops.dagstuhl.de/opus/volltexte/2014/4623/pdf/p001-01-ahman.pdf). Algebra for the update monad is a set with an operation, called **act**. Such algebra is formulised in file `MonadAlgebras.agda`.

However, we also learn in the article, that algebras for update monads specifically can also be presented with two more intuitive operations, **update** and **lookup**. This representation is coded in file `UpdateMonadAlgebras.agda`.

## Interdefinability

Proofs, that both definitions of algebras of update monads are equivalent, are written in `UpdateMonadAlgebras.agda`.

At first we proved, that a combination of *lookup* and *update* operations (specifically described in the article) suits as an *act* operation (by using some properties of *lookup* and *update*) for the first case of algebras of update monads.

Then we reversed the situation: we wrote *lookup* and *update* functions with *act* operation and then used some properties of *act* to prove needed laws of *lookup* and *update*.

## Compatible compositions

While state monads cannot be described as compatible compositions of reader and writer monads, update monads are exactly that. **Compatible composition** of two monads is definied in file `MonadComposition.agda`. Distributive law of one monad over other is also defined there. 

The idea is that functor of the update monad is exactly a composition of functors of reader and writer monads. Distributive law of the writer monad over reader monad defines the right action for the update monad. Those properties are formulised in `UpdateMonadComposition.agda`.

## Examples

Some special cases of update, reader and writer monads are described and formulised in `Examples.agda`:
- reader monad as a special case of update monad
- writer monad as a special case of update monad
- update monad that does reader's and writer's jobs separately
- a computation takes an initial state to the list of all intermediate states